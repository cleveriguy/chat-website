<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Starlight Runner ‚Äî HTML5 Canvas Game Starter</title>
  <style>
    :root {
      --bg: #0b1020; /* Deep space */
      --fg: #e6f2ff; /* UI text */
      --accent: #79f2ff; /* Neon cyan */
      --accent2: #ffd166; /* Gold */
      --danger: #ff6b6b; /* Enemy */
      --muted: #90a4ae; /* Dim UI */
    }
    html, body {
      margin: 0;
      height: 100%;
      background: radial-gradient(1200px 800px at 10% 20%, #111833, var(--bg));
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
      overflow: hidden; /* Prevent mobile bounce */
    }
    #gameWrap {
      position: relative;
      width: 100vw; height: 100vh;
    }
    canvas { 
      display: block; 
      width: 100%; height: 100%;
      /* crisp pixels for retro look */
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    .hud {
      position: absolute; inset: 0; pointer-events: none;
      display: grid; grid-template-rows: auto 1fr auto; 
      padding: 12px;
    }
    .row { display: flex; gap: 12px; align-items: center; }
    .space-between { justify-content: space-between; }
    .chip { pointer-events:auto; user-select:none; padding:6px 10px; border-radius:999px; border:1px solid #233; background:#0e162f99; backdrop-filter: blur(4px); }
    .chip button { all: unset; cursor: pointer; color: var(--fg); }
    .muted { color: var(--muted); }
    .accent { color: var(--accent); }

    /* Center overlays */
    .overlay {
      position:absolute; inset:0; display:grid; place-items:center; pointer-events:auto;
      background: radial-gradient(400px 300px at 50% 40%, #0e162fAA, #0e162f66 50%, transparent 70%);
    }
    .panel { max-width: 680px; padding: 24px; border: 1px solid #2a3b5a; border-radius: 16px; background: #0c1329cc; box-shadow: 0 10px 40px #0008; }
    .title { font-size: clamp(24px, 6vw, 48px); font-weight: 800; letter-spacing: 1px; margin-bottom: 6px; }
    .subtitle { color: #cfd8dc; margin-bottom: 18px; }
    .btnRow { display: flex; gap: 12px; flex-wrap: wrap; }
    .btn { pointer-events:auto; user-select:none; display:inline-flex; align-items:center; gap:8px; padding: 10px 14px; border-radius: 12px; cursor:pointer; border:1px solid #254; background:#11283a; color:#eaffff; font-weight:600; }
    .btn.primary { background: linear-gradient(180deg, #1f8faa, #146a8e); border-color:#146a8e; }
    .btn.warn { background: linear-gradient(180deg, #ab1f1f, #8e1414); border-color:#8e1414; }

    /* Touch controls (auto-hide on non-touch) */
    #touch { position:absolute; inset:0; display:none; pointer-events:none; }
    .touchpad { position:absolute; bottom:20px; left:20px; width:160px; height:160px; border-radius:50%; border:1px dashed #345; background:#0b162655; pointer-events:auto; touch-action:none; }
    .touchbtn { position:absolute; bottom:40px; right:24px; width:84px; height:84px; border-radius:50%; border:1px solid #345; background:#0b162699; pointer-events:auto; display:grid; place-items:center; font-weight:700; }
    @media (pointer:none), (pointer:coarse) { #touch { display:block; } }
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="game" width="960" height="540" aria-label="Starlight Runner game area"></canvas>

    <!-- HUD -->
    <div class="hud" aria-hidden="false">
      <div class="row space-between">
        <div class="chip"><span class="muted">Score:</span> <span id="score">0</span></div>
        <div class="row" style="gap:8px;">
          <div class="chip"><span class="muted">FPS:</span> <span id="fps">0</span></div>
          <div class="chip"><button id="btnPause" title="Pause/Resume (P)">‚è∏Ô∏é Pause</button></div>
          <div class="chip"><button id="btnMute" title="Mute/Unmute (M)">üîä Sound</button></div>
        </div>
      </div>
      <div></div>
      <div class="row space-between muted">
        <div>Move: WASD / ‚Üê‚Üë‚Üí‚Üì ‚Ä¢ Dash: Space ‚Ä¢ Pause: P ‚Ä¢ Restart: R</div>
        <div>Touch: joystick + A</div>
      </div>
    </div>

    <!-- Menus -->
    <div id="menu" class="overlay" role="dialog" aria-modal="true">
      <div class="panel">
        <div class="title">Starlight Runner</div>
        <div class="subtitle">Dodge hostile drones, collect starlight, and survive as long as you can.</div>
        <div class="btnRow">
          <button class="btn primary" id="btnStart">‚ñ∂ Start</button>
          <button class="btn" id="btnCredits">üè† Home</button>
          <button class="btn" id="btnHow">‚ùì How to Play</button>
        </div>
        <details style="margin-top:12px;">
          <summary class="muted">Advanced (dev)</summary>
          <div style="margin-top:8px; font-size:14px; color:#b0bec5;">
            ‚Ä¢ This is a clean HTML5 canvas starter: resize-safe, delta-time loop, input handler, entities, collision, & scene states.<br/>
            ‚Ä¢ Tweak constants in <code>CONFIG</code>. Extend by adding more <code>systems</code> and <code>entities</code>.
          </div>
        </details>
      </div>
    </div>

    <div id="gameOver" class="overlay" style="display:none;" role="dialog" aria-modal="true">
      <div class="panel" style="text-align:center;">
        <div class="title" style="color:var(--danger)">Game Over</div>
        <div class="subtitle">Score: <span id="finalScore">0</span></div>
        <div class="btnRow" style="justify-content:center;">
          <button class="btn primary" id="btnRetry">‚Üª Retry</button>
          <button class="btn" id="btnMenu">Menu</button>
        </div>
      </div>
    </div>

    <!-- Touch Controls -->
    <div id="touch" aria-hidden="false">
      <div id="stick" class="touchpad" aria-label="Virtual joystick"></div>
      <div id="btnA" class="touchbtn" aria-label="Dash button">A</div>
    </div>
  </div>

  <script>
  (function(){
    'use strict';

    // ---------------------------
    // Config
    // ---------------------------
    const CONFIG = {
      baseWidth: 480, // logical pixels (scaled to canvas)
      baseHeight: 270,
      player: { speed: 180, dashSpeed: 700, dashTime: 0.5, dashCooldown: 0.9, radius: 7 },
      enemy: { speedMin: 40, speedMax: 120, spawnEvery: 1.6, radius: 8 },
      star:  { spawnEvery: 1.5, radius: 5 },
      worldPadding: 24,
      maxEnemies: 300,
      sounds: true,
    };

    // ---------------------------
    // Helpers
    // ---------------------------
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const rand = (a, b) => a + Math.random()*(b-a);
    const randi = (a, b) => Math.floor(rand(a, b));
    const dist2 = (ax, ay, bx, by) => (ax-bx)*(ax-bx) + (ay-by)*(ay-by);

    // Simple SFX via WebAudio (bleep-y, tiny footprint)
    const AudioSys = (()=>{
      const ctx = (window.AudioContext || window.webkitAudioContext) ? new (window.AudioContext||window.webkitAudioContext)() : null;
      let muted = !CONFIG.sounds;
      function beep(type= 'sine', freq = 440, dur = 0.06, vol=0.03){
        if (!ctx || muted) return;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = type; o.frequency.value = freq;
        g.gain.value = vol;
        o.connect(g); g.connect(ctx.destination);
        o.start();
        o.stop(ctx.currentTime + dur);
      }
      return {
        toggle(){ muted = !muted; return !muted; },
        muted(){ return muted; },
        pickup(){ beep('sine', 740, 0.05, 0.05); },
        hit(){ beep('square', 220, 0.12, 0.06); },
        dash(){ beep('sawtooth', 520, 0.07, 0.045); },
        start(){ beep('triangle', 660, 0.25, 0.035); },
      };
    })();

    // ---------------------------
    // Canvas + Resize
    // ---------------------------
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const hudScore = document.getElementById('score');
    const hudFps = document.getElementById('fps');

    let scale = 1; // logical -> screen
    const world = { w: CONFIG.baseWidth, h: CONFIG.baseHeight };

    function fitToScreen(){
      // keep aspect while filling viewport
      const vw = window.innerWidth, vh = window.innerHeight;
      const ar = CONFIG.baseWidth / CONFIG.baseHeight;
      let cw = vw, ch = Math.round(vw/ar);
      if (ch > vh) { ch = vh; cw = Math.round(vh*ar); }
      canvas.width = cw; canvas.height = ch;
      scale = cw / CONFIG.baseWidth;
    }
    window.addEventListener('resize', fitToScreen);
    fitToScreen();

    // ---------------------------
    // Input (keyboard + touch)
    // ---------------------------
    const Input = { 
      keys: new Set(),
      dash: false,
      stick: { x:0, y:0 },
    };

    window.addEventListener('keydown', e=>{
      const k = e.key.toLowerCase();
      if(['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d'].includes(k)) e.preventDefault();
      Input.keys.add(k);
      if(k===' ') { Input.dash = true; }
      if(k==='p') { togglePause(); }
      if(k==='r') { if (scene.current === Scenes.GAME) startGame(); }
      if(k==='m') { setMute(AudioSys.toggle()); }
    });
    window.addEventListener('keyup', e=>{
      Input.keys.delete(e.key.toLowerCase());
    });

    // Touch joystick
    const stick = document.getElementById('stick');
    const btnA = document.getElementById('btnA');
    let stickActive=false, stickCX=0, stickCY=0;
    function stickPos(e){
      const r = stick.getBoundingClientRect();
      const t = (e.touches? e.touches[0]:e);
      const x = t.clientX - r.left; const y = t.clientY - r.top;
      const dx = x - r.width/2; const dy = y - r.height/2;
      const m = Math.hypot(dx, dy) || 1; const lim = r.width*0.35;
      const nx = clamp(dx, -lim, lim), ny = clamp(dy, -lim, lim);
      const mag = Math.min(1, m / lim);
      stick.style.background = `radial-gradient(${lim*2}px ${lim*2}px at ${x}px ${y}px, #1b2b4f99, #0b162655)`;
      Input.stick.x = nx/lim; Input.stick.y = ny/lim;
    }
    stick.addEventListener('pointerdown', e=>{ stickActive=true; stick.setPointerCapture(e.pointerId); stickPos(e); });
    stick.addEventListener('pointermove', e=>{ if(stickActive) stickPos(e); });
    stick.addEventListener('pointerup', e=>{ stickActive=false; Input.stick.x=0; Input.stick.y=0; stick.style.background = ''; });

    btnA.addEventListener('pointerdown', ()=>{ Input.dash = true; });

    // ---------------------------
    // Entities & Systems
    // ---------------------------
    const Entities = [];
    const PlayerTag = Symbol('player');
    const EnemyTag = Symbol('enemy');
    const StarTag = Symbol('star');

    function makePlayer(x,y){
      return {
        tag: PlayerTag,
        x, y, vx:0, vy:0, r: CONFIG.player.radius,
        dash: { t:0, cd:0 },
        alive: true,
        score: 0,
      };
    }
    function makeEnemy(x,y, angle){
      const speed = rand(CONFIG.enemy.speedMin, CONFIG.enemy.speedMax);
      return { tag: EnemyTag, x, y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, r: CONFIG.enemy.radius };
    }
    function makeStar(x,y){ return { tag: StarTag, x, y, r: CONFIG.star.radius }; }

    // Simple collision check (circle)
    function collides(a, b){ return dist2(a.x,a.y,b.x,b.y) <= (a.r+b.r)*(a.r+b.r); }

    // Spawners
    let enemyTimer = 0, starTimer=0;
    function spawnEnemy(){
      // spawn outside screen edges and move inward
      const side = randi(0,4); // 0 top,1 right,2 bottom,3 left
      let x, y;
      if (side===0){ x = rand(-CONFIG.worldPadding, world.w+CONFIG.worldPadding); y = -CONFIG.worldPadding; }
      if (side===1){ x = world.w+CONFIG.worldPadding; y = rand(-CONFIG.worldPadding, world.h+CONFIG.worldPadding); }
      if (side===2){ x = rand(-CONFIG.worldPadding, world.w+CONFIG.worldPadding); y = world.h+CONFIG.worldPadding; }
      if (side===3){ x = -CONFIG.worldPadding; y = rand(-CONFIG.worldPadding, world.h+CONFIG.worldPadding); }
      const cx = world.w/2, cy = world.h/2;
      const ang = Math.atan2(cy - y, cx - x) + rand(-0.5,0.5);
      Entities.push(makeEnemy(x,y,ang));
    }
    function spawnStar(){
      const x = rand(16, world.w-16), y = rand(16, world.h-16);
      Entities.push(makeStar(x,y));
    }

    // ---------------------------
    // Rendering (retro vector style)
    // ---------------------------
    function drawBackground(){
      // parallax starfield
      ctx.save();
      ctx.scale(scale, scale);
      ctx.fillStyle = '#07101f';
      ctx.fillRect(0,0,world.w,world.h);
      const t = timeTotal * 0.02;
      ctx.fillStyle = '#0f1a2f';
      for(let i=0;i<140;i++){
        const x = (i*37.13 + t*40) % (world.w+40) - 20;
        const y = (i*19.91 + Math.sin(i+t)*30) % (world.h+20) - 10;
        ctx.fillRect(x,y,2,2);
      }
      ctx.restore();
    }

    function drawEntity(e){
      ctx.save();
      ctx.scale(scale, scale);
      if(e.tag===PlayerTag){
        // Player: neon triangle ship
        ctx.translate(e.x, e.y);
        const speed = Math.hypot(e.vx, e.vy);
        const ang = Math.atan2(e.vy, e.vx) || 0;
        ctx.rotate(ang);
        ctx.beginPath();
        ctx.moveTo(10,0); ctx.lineTo(-10,6); ctx.lineTo(-6,0); ctx.lineTo(-10,-6); ctx.closePath();
        ctx.fillStyle = e.dash.t>0 ? '#9ff' : '#6cf';
        ctx.shadowColor = '#6cf';
        ctx.shadowBlur = e.dash.t>0 ? 24 : 12;
        ctx.fill();
        // engine trail
        ctx.beginPath();
        ctx.moveTo(-10,0); ctx.lineTo(-16, speed>10? (Math.random()*2-1)*2:0); ctx.lineTo(-10,2);
        ctx.fillStyle = '#79f2ff88';
        ctx.fill();
      } else if (e.tag===EnemyTag){
        // Enemy: red diamond drone
        ctx.translate(e.x, e.y);
        ctx.rotate((timeTotal*0.004) % (Math.PI*2));
        ctx.fillStyle = '#ff6b6b';
        ctx.shadowColor = '#ff6b6b';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.moveTo(0,-10); ctx.lineTo(10,0); ctx.lineTo(0,10); ctx.lineTo(-10,0); ctx.closePath();
        ctx.fill();
      } else if (e.tag===StarTag){
        ctx.translate(e.x, e.y);
        ctx.fillStyle = '#ffd166';
        ctx.shadowColor = '#ffd166';
        ctx.shadowBlur = 12;
        ctx.beginPath();
        ctx.arc(0,0,4,0,Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    // ---------------------------
    // Game Loop & Logic
    // ---------------------------
    let lastTime = performance.now();
    let timeTotal = 0; // ms
    let fps = 0, fpsAcc=0, fpsCount=0;

    const Scenes = { MENU: 'menu', GAME: 'game', OVER: 'over' };
    const scene = { current: Scenes.MENU };
    let player;

    function startGame(){
      // reset state
      Entities.length = 0;
      enemyTimer = 0; starTimer=0; timeTotal = 0; lastTime = performance.now();
      player = makePlayer(world.w/2, world.h/2);
      Entities.push(player);
      scene.current = Scenes.GAME;
      document.getElementById('menu').style.display = 'none';
      document.getElementById('gameOver').style.display = 'none';
      AudioSys.start();
    }

    function gameOver(){
      scene.current = Scenes.OVER;
      document.getElementById('finalScore').textContent = player.score;
      document.getElementById('gameOver').style.display = 'grid';
      AudioSys.hit();
    }

    function update(dt){
      if(scene.current !== Scenes.GAME) return;

      timeTotal += dt*1000;

      // spawn logic
      enemyTimer -= dt; starTimer -= dt;
      if (enemyTimer <= 0 && Entities.filter(e=>e.tag===EnemyTag).length < CONFIG.maxEnemies) {
        spawnEnemy(); enemyTimer = CONFIG.enemy.spawnEvery * rand(0.6,1.4);
      }
      if (starTimer <= 0) { spawnStar(); starTimer = CONFIG.star.spawnEvery * rand(0.7,1.3); }

      // input vector
      let ix = 0, iy = 0;
      if (Input.keys.has('w') || Input.keys.has('arrowup')) iy -= 1;
      if (Input.keys.has('s') || Input.keys.has('arrowdown')) iy += 1;
      if (Input.keys.has('a') || Input.keys.has('arrowleft')) ix -= 1;
      if (Input.keys.has('d') || Input.keys.has('arrowright')) ix += 1;
      // blend with touch stick
      ix += Input.stick.x; iy += Input.stick.y;
      const im = Math.hypot(ix, iy) || 1; ix/=im; iy/=im;

      // player move
      if (player.alive){
        // dash
        player.dash.cd = Math.max(0, player.dash.cd - dt);
        player.dash.t = Math.max(0, player.dash.t - dt);
        const dashReady = player.dash.cd<=0;
        if (Input.dash && dashReady && (ix||iy)){
          player.dash.t = CONFIG.player.dashTime;
          player.dash.cd = CONFIG.player.dashCooldown;
          AudioSys.dash();
        }
        Input.dash = false; // one-shot

        const speed = player.dash.t>0 ? CONFIG.player.dashSpeed : CONFIG.player.speed;
        player.vx = ix * speed; player.vy = iy * speed;
        player.x = clamp(player.x + player.vx*dt, 8, world.w-8);
        player.y = clamp(player.y + player.vy*dt, 8, world.h-8);
      }

      // enemies
      for (const e of Entities){
        if(e.tag !== EnemyTag) continue;
        e.x += e.vx*dt; e.y += e.vy*dt;
        // bounce inside padded world
        if (e.x < -CONFIG.worldPadding || e.x>world.w+CONFIG.worldPadding) e.vx *= -1;
        if (e.y < -CONFIG.worldPadding || e.y>world.h+CONFIG.worldPadding) e.vy *= -1;
      }

      // collisions
      for (let i=Entities.length-1; i>=0; i--){
        const a = Entities[i];
        if(a.tag===StarTag && collides(a, player)){
          Entities.splice(i,1); player.score += 10; hudScore.textContent = player.score; AudioSys.pickup(); continue;
        }
      }
      if (player.alive){
        const deadly = Entities.filter(e=>e.tag===EnemyTag);
        for (const e of deadly){
          if (collides(player, e)){
            if (player.dash.t>0){
              // dash-through destroys enemy
              e.x = -9999; e.y=-9999; e.vx = 0; e.vy=0;
              player.score += 3; hudScore.textContent = player.score; AudioSys.pickup();
            } else {
              player.alive = false; setTimeout(gameOver, 150); break;
            }
          }
        }
      }
    }

    function render(){
      drawBackground();
      // play area frame
      ctx.save();
      ctx.scale(scale, scale);
      ctx.strokeStyle = '#1c2947'; ctx.lineWidth = 2; ctx.strokeRect(8,8, world.w-16, world.h-16);
      ctx.restore();

      for(const e of Entities){ drawEntity(e); }
    }

    let paused = false;
    function togglePause(){ if(scene.current!==Scenes.GAME) return; paused = !paused; document.getElementById('btnPause').textContent = paused? '‚ñ∂ Resume':'‚è∏Ô∏é Pause'; }
    function setMute(on){ document.getElementById('btnMute').textContent = on? 'üîä Sound':'üîá Muted'; }

    function loop(now){
      const dt = Math.min(0.033, (now - lastTime)/1000); // clamp dt to avoid big jumps
      lastTime = now;
      // fps calc
      const inst = 1/Math.max(dt, 1e-6); fpsAcc += inst; fpsCount++;
      if (fpsCount>=10){ fps = Math.round(fpsAcc/fpsCount); hudFps.textContent = fps; fpsAcc=0; fpsCount=0; }

      if(scene.current===Scenes.GAME && !paused){ update(dt); }
      render();

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // ---------------------------
    // UI wiring
    // ---------------------------
    document.getElementById('btnStart').addEventListener('click', startGame);
    document.getElementById('btnHow').addEventListener('click', ()=>{
      alert('Move with WASD/Arrows (or touch joystick). Dash with Space/A to pass through drones and break them. Collect glowing starlight orbs for points. Avoid drones unless dashing. P to pause, R to restart.');
    });
    document.getElementById('btnRetry').addEventListener('click', startGame);
    document.getElementById('btnMenu').addEventListener('click', ()=>{ scene.current=Scenes.MENU; document.getElementById('menu').style.display='grid'; document.getElementById('gameOver').style.display='none'; });
    document.getElementById('btnPause').addEventListener('click', togglePause);
    document.getElementById('btnMute').addEventListener('click', ()=> setMute(AudioSys.toggle()));
document.getElementById('btnCredits').addEventListener('click', ()=>{
  window.location.href = "home.html";
});
    // Accessibility: resume audio on first user gesture (mobile autoplay policy)
    window.addEventListener('pointerdown', ()=>{ if (AudioSys.muted()) return; /* touching initializes context */ });

    // Expose for easy hacking in console
    window.__GAME__ = { Entities, CONFIG };
  })();
  </script>
</body>
</html>
